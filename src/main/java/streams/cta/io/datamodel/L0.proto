syntax="proto2";
import "CoreMessages.proto";

package streams.cta.io.datamodel;

/*********************
 * Waveform data for a given channel, for the entire camera
 *********************/
message WaveFormData
{
	optional AnyArray samples       = 1; //actual waveforms
	optional AnyArray pixelsIndices = 2; //indices of pixels that are present
	optional AnyArray firstSplIdx   = 3; //first recorded sample from the readout window. for timing purposes
	optional fixed32  num_samples   = 4 [default=0];//number of waveform sample for each pixel
}

/*********************
 * Integral data for a given channel, for the entire camera
 *********************/
message IntegralData
{
	optional AnyArray gains          = 1; //integrated gain
	optional AnyArray maximumTimes   = 2; //sample index of the maximum
	optional AnyArray tailTimes      = 3; //number of samples of the tail
	optional AnyArray raiseTimes     = 4; //number of samples while the signal is rising
	optional AnyArray pixelsIndices  = 5; //indices of pixels that are present
	optional AnyArray firstSplIdx    = 6; //first recorded sample from the readout window. for timing purposes
}

/*********************
 * The grouping of waveform and integrals for a given channel
 *********************/
message PixelsChannel
{
	optional WaveFormData waveforms = 1;
	optional IntegralData integrals = 2;
}

/*********************
 * Trigger from one camera
 *********************/
message CameraTrigger
{
	optional sfixed32 telescopeID = 1 [default=0]; //ID of the telescope that triggered
	optional sfixed64 timeSec     = 2 [default=0]; //time of the trigger
	optional sfixed64 timeNanoSec = 3 [default=0]; //time of the trigger
	optional fixed32  eventNumber = 4 [default=0]; //internal camera's event counter
}

/*********************
 * Trigger for a subarray - just a bunch of camera triggers
 *********************/
message ArrayTrigger
{
	optional fixed32        arrayEvtNum = 1 [default=0];  //global counter of array triggers for this subarray
	optional fixed32        num_cameras = 2;
	repeated CameraTrigger  cameras     = 3;
}

/*********************
 * Configuration data sent before every run. I am not sure that this should be coming from the camera itself, but rather
 * the cameras should receive it from the master, along with the relevant DAQ and RTA components
 *********************/
enum ImgReducMode
{
	NO_IMG_REDUC 		 = 0;
	ZERO_SUPPR 			 = 1;
	INTEGRATION 		 = 2;
	INTEG_AND_ZERO_SUPPR = 3;
}

enum EvtsReducMode
{
	NO_EVT_REDUC 	 = 0;
	TIME_COINCIDENCE = 1;
	IMAGE_PARAMS     = 2;
	HIGH_LEVEL_ANA   = 3;
}

message CameraRunHeader
{
	optional sfixed32      telescopeID       = 1 [default=-1]; //which telescope is this ?
	optional fixed32       runNumber         = 2 [default=0];  //new run number
	optional fixed32       dateMJD           = 3 [default=0];  //date when the new run was received
	optional fixed64       timeNanoSec       = 4 [default=0];  //precise date of start for the new run (for sorting events)
	optional ImgReducMode  imgReducMode      = 5 [default=NO_IMG_REDUC]; //data reduction mode for this current telescope
	optional EvtsReducMode evtsReducMode     = 6 [default=NO_EVT_REDUC];
	optional sfixed32      numTraces         = 7 [default=-1]; //number of traces recorded per waveform
	optional sfixed32      numGainChannels   = 8 [default=-1]; //number of gains outputted by this camera
	optional sfixed32      integWindowSize   = 9 [default=-1]; //how many samples are integrated (only if data reduction is enabled)
	optional sfixed32      integThreshold    = 10 [default=-1]; //what is the minimum level before integrating the pixels
	optional sfixed32      zeroSuppThreshold = 11 [default=-1]; //what is the minimum level before removing the pixel's data
}

/*********************
 * One full camera event. This is the structure that would be given to the FITS writer.
 * New fields would be automatically be taken into account thanks to the C++ reflexion features of the protobufs
 *********************/
enum EventType
{
	NONE         = 0;
	PHYSICAL     = 1;
	PEDESTAL     = 2;
	LIGHT_PULSER = 3;
}


message CircleParams
{
	optional double x = 1;
	optional double y = 2;
	optional double r = 3;
}

message CameraLocation
{
	optional double x   = 1; //position of the telescope
	optional double y   = 2;
	optional double z   = 3;
	optional double az  = 4;
	optional double alt = 5;
}

message CameraGeometry
{
	repeated CircleParams   pixels     = 1;
	optional double         rotation   = 2;
	optional double         foc_length = 3;
	optional int32			num_mirrors = 4;
	optional double			mirror_area = 5;
	optional CameraLocation pointing    = 6;
	optional double			sample_duration = 7;
}

message CameraEvent
{
	optional sfixed32        telescopeID = 1 [default=-1]; //ID of this telescope
	optional double          dateMJD  	 = 2 [default=0];  //camera server date when the event was generated
	optional EventType       eventType   = 3 [default=NONE];  //type of event, i.e. physical, pedestal...
	optional fixed32         eventNumber = 4 [default=0];  //internal camera's event counter
	optional fixed32         arrayEvtNum = 5 [default=0];  //corresponding array event number
	optional PixelsChannel   hiGain      = 6;
	optional PixelsChannel   loGain      = 7;
	optional CameraTrigger   trig        = 8;
	optional CameraRunHeader head        = 9; //could be added at some point (not written to disk) to simplify the processing
	optional CircleParams	 muon        = 10;
	optional CameraGeometry  geometry    = 11;
	optional sfixed32        hilo_offset = 12;
	optional sfixed32        hilo_scale  = 13;
}

message PacketLibData
{
	optional bytes data = 1;
}

message ShowerParams
{
	optional float azimuth    = 1;
	optional float altitude   = 2;
	optional float start_alt  = 3;
	optional float max_alt    = 4;
	optional float ch_max_alt = 5;
}

/*********************
 * One full array event. Just a bunch of camera events from different telescopes
 *********************/
message ArrayEvent
{
	optional ArrayTrigger triggerData = 1;
	repeated CameraEvent  cameraData  = 2;
	optional ShowerParams shower_params = 3;
}

